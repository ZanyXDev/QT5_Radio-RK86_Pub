Под SYMBUF имелся ввиду буфер на один символ, который заполняется при выполнении подпрограмм F812 и F81B. Этот буфер скопирован из консольных функций ROM-BIOS импортных компьютеров. Такой буфер есть и в CP/M. Дело в том, что импортные рэтро компьютеры использовали аппаратную клавиатуру, аналог которой это клавиатура от "Электроники-60" - 15ВВВ-97-006, Консул, клавиатура Агата и от всех DEC мини ЭВМ.

Аппаратная рэтро клавиатура выдаёт по нажатию прямо код ASCII сопровождаемый сигналом строб STB=0. В компьютере стоит триггер статуса, который взводится по фронту STB, а данные защелкиваются в регистре. Вот этот регистр и есть односимвольный буфер аппаратной клавиатуры. Компьютер непрерывно читает триггер статуса продпрограммой STATUS (F812). И как только оттуда считан не 0, значит в этом односимвольном входном буфере есть код. Компьютер может этот ASCII-код считать не сразу, а спустя полчаса. При считывании ASCII-кода триггер статуса автоматически сбрасывается.

В РК86 работа клавиатуры точно эмулирует эту идею. А вот ПЗУ Специалиста и ОРИОНА сделаны неправильно, - там нет буфера, потому, если определив по STATUS F812, что код в буфере есть, программа вслед за этим вызывает CONIN F803, чтобы этот код принять, то если пользователь к этому времени уже успел отпустить кнопку, то программа просто повисает на ожидании очередного нажатия. Для родных программ ОРИОНА это не вредит, т.к они уже знают о таком неправильном поведении подпрограмм. Понятно, что когда делалась CP/M для ОРИОНА и Специалиста это было легко учесть, - вместо STATUS вызывалась F81B, которая возвращает код нажатой именно в этот момент клавиши (чтение на лету). Полученный код кладётся в специально организуемый буфер. STATUS делается не прямым чтением, а за счёт вызова F81B. Потому, если STATUS выдал, что в буфере есть код, то вызов CONIN обязательно сразу вернёт код, немотря на то, что клавиша уже реально не нажимается.

Комментарии, скорее всего были взяты мной из другого уже доработанного исходника РК86, где возможно и была ячейка SYMBUF (вспомнить нельзя, это было 30 лет назад). Но скорее всего, я просто дописывал комментарий и написал коротко SYMBUF, чтобы не писать долго "односимвольный буфер ввода с консоли" или листать исходник, чтобы найти название конкретной ячейки. Мне и так было понятно о чём речь.

В качестве символьного буфера в данном исходнике служит ячейка LAST_K и Вы бы сами это увидели, посмотрев подпрограмму CONIN.
		
	
Code:
CONIN:  CALL    STATUS
        OR      A
        JP      Z,CONIN
        XOR     A
        LD      (KBDFLG),A
        LD      A,(LAST_K)
        RET

		

Здесь ячейка KBDFLG это флаг о том, что ранее при вызовах п/п-мм STATUS или XF81B было обнаружено нажатие клавиши, код которой положен в ячейку LAST_K (от Last Key - это последний код, что был считан с клавиатуры при вызовах F81B или F812).

Эта подпрограмма CONIN, если STATUS возвратил флаг, что символ в буфере есть, сбрасывает KBDFLG, а уже ранее подготовленный символ берёт из односимвольного буфера, ячейки LAST_K. Тем самым может считываться код клавиши, которую нажали час назад. Если же флаг KBDBUF не стоит, т.е ранее нажатий не было зафиксировано, то вызывается STATUS до тех пока не нажмут на какую-нибудь клавишу.

Лучше переименовать ячейку LAST_K в SYMBUF. При желании легко доработать ПЗУ так, чтобы консольный буфер был не односимвольным, а как в IBM PC, 16-ти символьным. Но особой нужды в этом нет, т.к нет процедур настолько надолго прерывающих прогон РК-программ.

Это в одноядерном PC, если, например, читается флоп или винт, то программа не реагирует на клавиши пока не закончится чтение. А это может быть от секунды до десятков секунд. Но если в это время нажимать на клавиши, то нажатия не пропадут, а уйдут в буфер клавиатуры. Если же Вы нажмёте клавишу более 16-ти раз, то буфер переполнится и клавиатура пискнет извещая Вас, что дальнейшие нажатия уже пропадут.

Я думаю, что и в IBM без большого клавиатурного буфера могли обойтись. Потому даже, если поставить винт или флоп в РК, то всё-равно нет смысла вводить большой консольный буфер. Достаточно не быть идиотом и не набирать ничего на клавиатуре когда процессор занят чем-то другим более срочным и не обслуживает клавиатуру. А в обычных программах для РК86 процессор 99% времени проводит в опросе клавиатуры. В секунду делается ~3000 вызовов подпрограммы F812 или F81B. Потому нажатия и не пропадают.

